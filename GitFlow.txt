// GitFlow 전략 --> 안정적인 운영이 필요하면 GitFlow
1. main - 본판 ~~> 완성이 다 된다면 합체 
2. develop - 신기능 코드 합치는 곳(개발용)
3. feature - 신기능 개발 하는 곳(develop에 기능 추가용) ~~> feature/어쩌구 라고 작명
4. release - develop을 main으로 합치기 전에 임시로 release 올리는 곳(develop 브랜치를 main 브랜치에 합치기 전에 최종 테스트용) ~~> v1.0 출시 전 여러가지 테스트 
5. hotfix - 오류 발생하면 고치는 곳(main 브랜치 버그해결용) ~~> 급하면 main에서 branch 생성 후 PR 해서 고친 후 반영 하는 방법도 있음.

// 운영 방식(예시)
1. develop 브랜치부터 생성 ~~>  main 브랜치에 있던 기존 프로젝트를 복사한 develop 브랜치를 생성합니다. 이제 모든 개발은 develop 브랜치에서 진행하라고 팀원들에게 전파합니다. 
2. 신기능개발은 feature 브랜치에서 진행 ~~> 신기능을 만들고 싶으면 develop 브랜치를 복사한 feature 브랜치에서 각각 개발합니다. 
2-1. 브랜치 작명할 때 여러 단어가 필요하면 보통 대시나 / 기호 씁니다
2-2. 완성되면 develop 브랜치에 merge 합니다.
2-3. 중요한 내용이 아니면 squash and merge도 괜찮습니다. 
3. 신버전 출시 준비는 release 브랜치
- 여기서 테스트나 QA같은거 진행하면 됩니다. 
- 버그를 발견하면 알아서 임시 브랜치 만들어서 수정하거나 합니다.
- release/1.0 이런 식으로 이쁘게 브랜치 이름을 짓는 경우가 많습니다.
- 완성된 것 같으면 main 브랜치로 merge 합니다. 그리고 그거 유저들에게 배포하면 됩니다. 
- 개발은 계속 진행되어야하니 완성본은 develop 브랜치에도 merge 해줍시다. 
4. hotfix 브랜치
- 수정이 완료되면 main 브랜치에 직접 merge 하면 됩니다. 
- 당연히 develop 브랜치에도 merge 해줘야합니다. 

// 장점 : 안정적으로 버전별 배포가능
// 단점 : CI/CD 이런거 하는 곳은 안 좋아함. ~~~> 상황에 맞춰서 쓰면 됨.

// GitFlow 형태 예시
main_v0.9 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - main_v1.0 - - - - - - - - - - - - - - -  main_v1.0.1
|                                                                                                                            |                                         |
|                                                                                                                            | - - - - - - - hotfix_v1.0.0 - - - hotfix_v1.0.1
|                                                                                                                            |                                         |
|                                                                             release_v0.9.0 - - - release_v0.9.1 - - - release_v0.9.2                                 |
|                                                                                   |                                        |                                         |
develop_v0.9 - - - - - - - - - - - - - - - - - - - develop_v0.9.1 - - - - - - develop_v0.9.2 - - - - - - - - - - - - - -develop_v1.0 - - - - - - - - - - - - - - develop_v1.0.1
|                                                           |                       |
|                                                           |                       |
feature/guild_v0.9.0 ----- feature/guild_v0.9.1 --- feature/guild_v0.9.2            |
                                    |                                               |
                                    |                                               |
                           feature/friend_v0.9.0 - - - - - - - - - - - - - - - - - - -
                    
// Trunk-based : 브랜치 하나만 잘 관리하자. ~~~> develop 그런 거 왜 씀?
1. 기능추가, 버그픽스가 필요하면 main 브랜치에서 새로운 브랜치를 하나 만들어서 코드짭니다.
- 브랜치마다 작명 잘하는게 중요합니다. 
2. 기능이 완성되었으면 main 브랜치에 합칩니다. ~~> 다 쓴 필요없는 브랜치는 삭제~~
3. main 브랜치에 있는 코드를 필요할 때 마다 유저들에게 배포합니다.

// 장점 : 소스코드가 한 곳에만 있음 --> 관리하기 편함 / 작은 단위로 merge 함.
// 단점 : 많은 테스트를 자주 해야함

// Trunk-based 형태 예시
feature1                  feature1_v0.0.1 - - - - feature1_v0.0.2 
                              |                        |
main_v0.0.0 - - - - - - - main_v0.0.1 - - - - - - main_v0.0.2 - - - - - - main_v0.0.3 - - - - main_v0.0.4
                                                       |                        |
feature2                                          feature2_v0.0.2 - - - - feature2_v0.0.3

// merge 할 때 어떤 방법 쓰는게 좋은가요?
기록을 남겨야하는 중요한 브랜치를 merge할 땐 --> 3-way merge
기록을 남길 필요없는 쓸데없는 브랜치를 merge할 땐 --> squash, rebase 쓰면 됩니다. 
취향일 뿐이고 알아서합시다. 